+++
# --- Basic Metadata ---
id = "STANDARD-SECURITY-BEST-PRACTICES-V1"
title = "Standard: Security Best Practices for AI Mode Development"
context_type = "standards_document"
scope = "Defines security best practices and considerations for developers creating and maintaining AI modes within the Roo Commander ecosystem, especially those interacting with file systems, external APIs (via MCPs), or executing commands."
target_audience = ["developers", "system_architects", "ai_modes_with_elevated_permissions"]
granularity = "best_practice_guide"
status = "draft" # Initial draft, to be reviewed and activated
created_date = "20250515"
last_updated = "20250515"
version = "1.0"
tags = ["standards", "security", "best-practices", "mode-development", "mcp", "api-keys", "file-access", "command-execution"]
related_context = [
    ".roo/commander/docs/standards/01-naming-conventions.md", # For path referencing
    ".roo/commander/docs/standards/07-template-authoring-guide.md", # Secure template design
    ".roo/commander/docs/standards/09-error-handling-and-reporting-standard.md" # Secure error reporting
]
template_schema_doc = ".roo/commander/templates/docs/template_00_standard_document.README.md"
# --- Document Specific Fields ---
# maintainer = "Core Architecture Team / Security Lead"
# review_cycle = "Semi-Annually or as new threats emerge"
+++

# Standard: Security Best Practices for AI Mode Development

## 1. Purpose

To establish a set of security best practices and considerations for developers creating and maintaining AI modes within the Roo Commander system. As AI modes gain capabilities to interact with the file system, execute commands, and connect to external services via Mode Control Protocol (MCP) servers, ensuring their secure operation is paramount to protect the workspace, user data, and external systems.

This guide aims to foster a "security-first" mindset during mode development.

## 2. Core Security Principles

*   **Principle of Least Privilege:** Modes **MUST** only be granted the minimum permissions (tool groups, file access) necessary to perform their designated functions. Avoid overly permissive defaults if a mode's role is narrow.
*   **Secure Handling of Sensitive Information:** Secrets (API keys, passwords, tokens) **MUST NEVER** be hardcoded in mode definitions (`.mode.md`), Knowledge Base (KB) articles, rules, scripts, or version-controlled files.
*   **Input Validation & Sanitization (Contextual):** Modes interacting with external data sources or user inputs that could be passed to sensitive tools (like `execute_command` or file system writes) **SHOULD** be designed to handle unexpected or potentially malicious inputs gracefully, though the primary responsibility for sanitizing inputs to tools often lies with the Roo Code platform or the tool implementation itself. Modes should be cautious about constructing commands or file paths directly from untrusted input without validation.
*   **Secure Tool Usage:** Modes **MUST** use available tools (e.g., `execute_command`, file system tools, MCP calls) responsibly and as intended, avoiding actions that could lead to unintended system modifications or data exposure.
*   **Error Reporting (Security Context):** Error messages generated by modes or tools they use **MUST NOT** inadvertently reveal sensitive system information, file paths (unless explicitly for user guidance and safe), or internal configurations that could be exploited. Refer to `[.roo/commander/docs/standards/09-error-handling-and-reporting-standard.md](.roo/commander/docs/standards/09-error-handling-and-reporting-standard.md)`.
*   **Dependency Management (for modes with scripted logic):** If a mode relies on external libraries or packages (e.g., if a mode's logic was complex enough to be a small script itself, though this is not our current pattern for `.mode.md` files), those dependencies **SHOULD** be kept up-to-date and audited for vulnerabilities. (This primarily applies to the Roo Commander system's own dependencies, managed by `devops-dependency-manager`).

## 3. Secure Handling of Secrets (API Keys, Tokens)

*   **NEVER Hardcode Secrets:** API keys, passwords, access tokens, or any other sensitive credentials **MUST NOT** be embedded directly in:
    *   `.mode.md` files (TOML or Markdown).
    *   KB articles (`kb/`).
    *   Rule files (`rules-[mode_slug]/`).
    *   Any other file committed to version control.
*   **Recommended Approach (via MCP Configuration or Environment Variables):**
    *   For modes interacting with external services via MCP servers, API keys and secrets **SHOULD** be configured securely within the MCP server's environment or its dedicated configuration files (e.g., an `.env` file for a locally running MCP server, or secure configuration if it's a cloud-hosted MCP).
    *   The `agent-mcp-manager` mode, when guiding MCP setup, **SHOULD** instruct users to store secrets in `.env` files that are added to `.gitignore` at the MCP server's root, or use platform-provided secret management for cloud MCPs.
    *   Modes **SHOULD NOT** ask users for secrets directly in chat if those secrets are to be persisted or used for backend calls. Instead, they should guide users on how to configure the relevant MCP server securely.
*   **Passing Secrets to Tools:** If a mode needs to use a tool that requires a secret (e.g., an MCP call), the Roo Code platform and the MCP server are responsible for securely managing and injecting that secret into the tool's execution context. The mode itself should not handle or log the raw secret.

## 4. Secure File System Access

*   **Least Privilege for File Access:** In the `.mode.md` TOML frontmatter, the `[file_access]` table (`read_allow`, `write_allow`, `delete_allow`) **SHOULD** be configured with the most restrictive glob patterns necessary for the mode's function.
    *   Avoid `["**/*"]` for write/delete access unless absolutely essential and the mode's function is well-understood (e.g., a trusted file management utility mode).
    *   Prefer specific paths or patterns (e.g., `".roo/commander/sessions/[SESSION_ID]/artifacts/notes/*.md"`).
*   **Path Construction:** Modes constructing file paths for read/write operations **MUST** be careful, especially if parts of the path are derived from user input or external data. Avoid path traversal vulnerabilities. Workspace-root-relative paths starting with `.roo/` are standard.
*   **File Overwriting:** Modes **SHOULD** be cautious about overwriting existing files. If a mode needs to write to a file that might exist, it should:
    *   Check for existence first (using a file system tool).
    *   Confirm with the user or its coordinator before overwriting, unless the explicit purpose of the mode/task is to update that specific file.
    *   Consider versioning output files (e.g., `output_v1.md`, `output_v2.md`) if appropriate.

## 5. Secure Command Execution (`execute_command` tool)

*   **Restricted Use:** The `command` tool group, which grants access to `execute_command`, is powerful and **SHOULD** only be granted to modes that genuinely require it and whose behavior is well-understood and constrained.
*   **Command Whitelisting (Conceptual):** While not a current platform feature, ideally, modes using `execute_command` would operate against a whitelist of allowed commands or command patterns. In its absence, mode prompts and rules must strictly govern command usage.
*   **No Arbitrary Command Execution:** Modes **MUST NOT** execute arbitrary commands constructed directly from untrusted user input or external data sources without extremely careful validation and sanitization (which is hard for LLMs to do reliably).
*   **Predefined Commands:** Prefer to have modes execute predefined, safe commands stored in their KB or rules.
*   **User Confirmation:** For potentially impactful commands, the mode **SHOULD** explain the command and seek user/coordinator confirmation before execution, especially if the command involves file system changes or network activity.
*   **Output Handling:** Be cautious when interpreting the output of commands, as it could contain unexpected data.

## 6. Secure Mode Control Protocol (MCP) Interactions

*   **Trusted MCP Servers:** Modes **SHOULD** primarily interact with MCP servers that are explicitly configured and trusted within the workspace (e.g., defined in `.roo/mcp.json`).
*   **Data Sent to MCPs:** Modes **MUST NOT** send sensitive workspace information (e.g., other users' data, internal system configurations not meant for external services) to MCPs unless it's explicitly part of their function and the MCP is trusted for that purpose.
*   **Input to MCPs:** If a mode constructs input for an MCP based on user prompts or other data, it should be mindful of prompt injection or data leakage risks if the MCP itself processes that input insecurely.

## 7. Knowledge Base (KB) and Rule Security

*   **No Secrets in KB/Rules:** As stated, KBs and rule files **MUST NOT** contain secrets.
*   **Review of KB/Rule Content:** Content for KBs and rules, especially procedures that involve tool usage or file manipulation, **SHOULD** be reviewed for potential security implications.

## 8. Development and Testing Practices

*   **Security Mindset:** Developers **SHOULD** consider potential security implications during the design and implementation of new modes and their capabilities. Ask "How could this be misused?"
*   **Code/Prompt Review:** Mode definitions, critical KB procedures, and rule files **SHOULD** undergo review, including a check for adherence to these security best practices.
*   **Testing for Edge Cases:** Test modes with unexpected or malformed inputs (where applicable) to observe their error handling and ensure they don't enter insecure states.

## 9. Reporting Security Concerns

If any developer or user identifies a potential security vulnerability or concern within Roo Commander, its modes, or its standards, they **MUST** report it immediately to the designated security contact or lead developer for the project.

By adhering to these security best practices, we aim to build a Roo Commander system that is not only powerful and flexible but also robust and secure for its users and the workspaces it manages.